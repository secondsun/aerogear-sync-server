/**
 * JBoss, Home of Professional Open Source
 * Copyright Red Hat, Inc., and individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jboss.aerogear.diffsync.server;

import org.jboss.aerogear.diffsync.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * The server side of the differential synchronization implementation.
 *
 * @param <T> The type of document that this implementation can handle.
 */
public class ServerSyncEngine<T> {

    private final ServerSynchronizer<T> synchronizer;
    private final ServerDataStore<T> dataStore;
    private static final Logger logger = LoggerFactory.getLogger(ServerSyncEngine.class);
    private static final int SEEDED_CLIENT_VERSION = -1;
    private static final int SEEDED_SERVER_VERSION = 1;

    public ServerSyncEngine(final ServerSynchronizer<T> synchronizer, final ServerDataStore<T> dataStore) {
        this.synchronizer = synchronizer;
        this.dataStore = dataStore;
    }

    /**
     * Adds a new document which is "synchonrizable".
     *
     * A server does not create a new document itself, this would be created by a client
     * and a first revision is added to this synchronization engine by this method call.
     *
     * @param document the document to add.
     */
    public Edits addDocument(final Document<T> document, final String clientId) {
        final boolean hasDocument = contains(document.id());
        if (!hasDocument) {
            dataStore.saveDocument(document);
        }

        final ShadowDocument<T> shadow = addShadowForClient(document.id(), clientId);
        final Edit edit;
        if (hasDocument) {
            logger.info("Document with id [" + document.id() + "] already exists.");
            // create a edit for the updates required to bring the client to the latest version.
            edit = serverDiff(shadow.document(), seededShadowFrom(shadow, document));
            // patch the shadow to match the latest version.
            patchDocument(shadow);
        } else {
            // need to increment the server version as we return a edits/patch message
            edit = serverDiff(shadow.document(), incrementServerVersion(shadow));
        }
        logger.info("addDocument edit=" + edit);
        return new DefaultEdits(document.id(), clientId, new LinkedList<Edit>(Collections.singleton(edit)));
    }

    private ShadowDocument<T> seededShadowFrom(final ShadowDocument<T> shadow, final Document<T> doc) {
        final ClientDocument<T> clientDoc = newClientDocument(doc.id(), shadow.document().clientId(), doc.content());
        return new DefaultShadowDocument<T>(SEEDED_SERVER_VERSION, SEEDED_CLIENT_VERSION, clientDoc);
    }

    /**
     * Performs the server side diff which is performed when the server document is modified.
     * The produced {@link Edit} can be sent to the client for patching the client side documents.
     *
     * @param documentId the document in question.
     * @param clientId the clientId for whom we should perform a diff and create edits for.
     * @return {@link Edit} The server edits, or updates, that were generated by this diff .
     */
    public Edit diff(final String documentId, final String clientId) {
        final Document<T> document = getDocument(documentId);
        final Edit edit = serverDiffs(document, clientId);
        diffPatchShadow(getShadowDocument(documentId, clientId), edit);
        return edit;
    }

    /**
     * Performs the server side patching for a specific client.
     *
     * @param edits the changes made by a client.
     */
    public void patch(final Edits edits) {
        final ShadowDocument<T> patchedShadow = patchShadow(edits);
        patchDocument(patchedShadow);
        saveBackupShadow(patchedShadow);
    }

    public Edits diffs(final String documentId, final String clientId) {
        diff(documentId, clientId);
        return new DefaultEdits(documentId, clientId, dataStore.getEdits(documentId, clientId));
    }

    private boolean contains(final String id) {
        return dataStore.getDocument(id) != null;
    }

    private void diffPatchShadow(final ShadowDocument<T> shadow, final Edit edit) {
        saveShadow(synchronizer.patchShadow(edit, shadow));
    }

    private ShadowDocument<T> addShadowForClient(final String documentId, final String clientId) {
        return addShadow(documentId, clientId, 0L);
    }

    private ShadowDocument<T> addShadow(final String documentId, final String clientId, final long clientVersion) {
        final Document<T> document = getDocument(documentId);
        final ClientDocument<T> clientDocument = newClientDocument(documentId, clientId, document.content());
        final ShadowDocument<T> shadowDocument = newShadowDoc(0, clientVersion, clientDocument);
        saveShadow(shadowDocument);
        saveBackupShadow(shadowDocument);
        return shadowDocument;
    }

    private Edit clientDiffs(final Document<T> document, final ShadowDocument<T> shadow) {
        return clientDiff(document, shadow);
    }

    private Edit serverDiffs(final Document<T> document, final String clientId) {
        final ShadowDocument<T> shadow = getShadowDocument(document.id(), clientId);
        final Edit newEdit = serverDiff(document, shadow);
        saveEdits(newEdit);
        saveShadow(incrementServerVersion(shadow));
        return newEdit;
    }

    private ShadowDocument<T> patchShadow(final Edits edits) {
        ShadowDocument<T> shadow = getShadowDocument(edits.documentId(), edits.clientId());
        final Iterator<Edit> iterator = edits.edits().iterator();
        while (iterator.hasNext()) {
            final Edit edit = iterator.next();
            if (droppedServerPacket(edit, shadow)) {
                shadow = restoreBackup(shadow, edit);
                continue;
            }
            if (hasClientUpdate(edit, shadow)) {
                discardEdit(edit, iterator);
                continue;
            }
            if (allVersionMatch(edit, shadow)) {
                final ShadowDocument<T> patchedShadow = synchronizer.patchShadow(edit, shadow);
                shadow = saveShadowAndRemoveEdit(incrementClientVersion(patchedShadow), edit);
            }
        }
        return shadow;
    }

    private ShadowDocument<T> restoreBackup(final ShadowDocument<T> shadow,
                                            final Edit edit) {
        final BackupShadowDocument<T> backup = getBackupShadowDocument(edit.documentId(), edit.clientId());
        if (serverVersionMatch(backup, edit)) {
            final ShadowDocument<T> patchedShadow = synchronizer.patchShadow(edit,
                    newShadowDoc(backup.version(), shadow.clientVersion(), backup.shadow().document()));
            dataStore.removeEdits(edit.documentId(), edit.clientId());
            return saveShadow(incrementClientVersion(patchedShadow));
        } else {
            throw new IllegalStateException(backup + " server version does not match version of " + edit.serverVersion());
        }
    }

    private void discardEdit(final Edit edit, final Iterator<Edit> iterator) {
        dataStore.removeEdit(edit);
        iterator.remove();
    }

    private ShadowDocument<T> saveShadowAndRemoveEdit(final ShadowDocument<T> shadow, final Edit edit) {
        dataStore.removeEdit(edit);
        return saveShadow(shadow);
    }

    private boolean serverVersionMatch(final BackupShadowDocument<T> backup, final Edit edit) {
        return backup.version() == edit.serverVersion();
    }

    private boolean droppedServerPacket(final Edit edit, final ShadowDocument<T> shadowDocument) {
        return edit.serverVersion() < shadowDocument.serverVersion();
    }

    private boolean hasClientUpdate(final Edit edit, final ShadowDocument<T> shadowDocument) {
        return edit.clientVersion() < shadowDocument.clientVersion();
    }

    private boolean allVersionMatch(final Edit edit, final ShadowDocument<T> shadowDocument) {
        return edit.serverVersion() == shadowDocument.serverVersion()
                && edit.clientVersion() == shadowDocument.clientVersion();
    }

    private Document<T> patchDocument(final ShadowDocument<T> shadowDocument) {
        final Document<T> document = getDocument(shadowDocument.document().id());
        final Edit edit = clientDiffs(document, shadowDocument);
        final Document<T> patched = synchronizer.patchDocument(edit, document);
        saveDocument(patched);
        logger.info("Patched Document [" + patched.id() + "] content: " + patched.content());
        return patched;
    }

    private Document<T> getDocument(final String documentId) {
        return dataStore.getDocument(documentId);
    }

    private ClientDocument<T> newClientDocument(final String documentId, final String clientId, final T content) {
        return new DefaultClientDocument<T>(documentId, clientId, content);
    }

    private ShadowDocument<T> getShadowDocument(final String documentId, final String clientId) {
        return dataStore.getShadowDocument(documentId, clientId);
    }

    private BackupShadowDocument<T> getBackupShadowDocument(final String documentId, final String clientId) {
        return dataStore.getBackupShadowDocument(documentId, clientId);
    }

    private Edit clientDiff(final Document<T> doc, final ShadowDocument<T> shadow) {
        return synchronizer.clientDiff(doc, shadow);
    }

    private Edit serverDiff(final Document<T> doc, final ShadowDocument<T> shadow) {
        return synchronizer.serverDiff(doc, shadow);
    }

    private void saveEdits(final Edit edit) {
        dataStore.saveEdits(edit);
    }

    private ShadowDocument<T> incrementClientVersion(final ShadowDocument<T> shadow) {
        final long clientVersion = shadow.clientVersion() + 1;
        return newShadowDoc(shadow.serverVersion(), clientVersion, shadow.document());
    }

    private ShadowDocument<T> saveShadow(final ShadowDocument<T> newShadow) {
        dataStore.saveShadowDocument(newShadow);
        return newShadow;
    }

    private ShadowDocument<T> newShadowDoc(final long serverVersion, final long clientVersion, final ClientDocument<T> doc) {
        return new DefaultShadowDocument<T>(serverVersion, clientVersion, doc);
    }

    private ShadowDocument<T> incrementServerVersion(final ShadowDocument<T> shadow) {
        final long serverVersion = shadow.serverVersion() + 1;
        return newShadowDoc(serverVersion, shadow.clientVersion(), shadow.document());
    }

    private void saveBackupShadow(final ShadowDocument<T> newShadow) {
        dataStore.saveBackupShadowDocument(new DefaultBackupShadowDocument<T>(newShadow.serverVersion(), newShadow));
    }

    private void saveDocument(final Document<T> document) {
        dataStore.saveDocument(document);
    }

}
